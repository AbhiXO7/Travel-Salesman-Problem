<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive GA-SA TSP Solver with Real-time Map</title>
    <script src="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 400px;
            height: 100vh;
            gap: 0;
        }

        .map-container {
            position: relative;
            background: #f8fafc;
            border-radius: 0;
        }

        #map {
            width: 100%;
            height: 100%;
            border-radius: 0;
        }

        .controls-panel {
            background: white;
            padding: 25px;
            overflow-y: auto;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e2e8f0;
        }

        .header h1 {
            color: #2d3748;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .header p {
            color: #718096;
            font-size: 14px;
        }

        .instructions {
            background: #f7fafc;
            border-left: 4px solid #4299e1;
            padding: 15px;
            margin-bottom: 25px;
            border-radius: 0 8px 8px 0;
            font-size: 13px;
            line-height: 1.5;
            color: #2d3748;
        }

        .input-group {
            margin-bottom: 18px;
        }

        .input-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #4a5568;
            font-size: 14px;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s ease;
            background: white;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        .points-list {
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .point-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: white;
            border-radius: 6px;
            margin-bottom: 6px;
            border: 1px solid #e2e8f0;
        }

        .point-item:last-child {
            margin-bottom: 0;
        }

        .point-coords {
            font-size: 12px;
            color: #718096;
            font-family: 'Courier New', monospace;
        }

        .point-remove {
            background: #fed7d7;
            border: none;
            color: #c53030;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .point-remove:hover {
            background: #fc8181;
            color: white;
        }

        .btn {
            width: 100%;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            display: inline-block;
            text-decoration: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #f7fafc;
            color: #4a5568;
            border: 2px solid #e2e8f0;
        }

        .btn-secondary:hover {
            background: #edf2f7;
            border-color: #cbd5e0;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(45, 55, 72, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10000;
            color: white;
        }

        .loading.show {
            display: flex;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading p {
            margin: 5px 0;
            font-size: 16px;
            text-align: center;
        }

        .results {
            background: #f0fff4;
            border: 2px solid #68d391;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            color: #22543d;
        }

        .results h3 {
            margin-bottom: 15px;
            color: #22543d;
        }

        .results p {
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .numbered-marker {
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            border: 3px solid white;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            cursor: pointer;
        }

        .numbered-marker.start {
            background: #48bb78;
            box-shadow: 0 2px 15px rgba(72, 187, 120, 0.5);
        }

        /* GA-SA specific styling */
        .algorithm-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .algorithm-info h3 {
            margin-bottom: 5px;
            font-size: 16px;
        }

        .algorithm-info p {
            font-size: 12px;
            opacity: 0.9;
        }

        .ga-parameters {
            background: #fef5e7;
            border: 1px solid #ed8936;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .ga-parameters h4 {
            color: #c05621;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .param-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .progress-bars {
            margin-top: 15px;
        }

        .progress-bar {
            background: #edf2f7;
            border-radius: 4px;
            height: 8px;
            margin-bottom: 8px;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 100%;
            transition: width 0.3s ease;
        }

        .progress-label {
            font-size: 11px;
            color: #4a5568;
            margin-bottom: 3px;
        }

        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: 60vh 1fr;
            }
            
            .controls-panel {
                max-height: 40vh;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="map-container">
            <div id="map"></div>
        </div>
        
        <div class="controls-panel">
            <div class="header">
                <h1>üß¨ Interactive GA-SA TSP Solver</h1>
                <p>Genetic Algorithm with Simulated Annealing</p>
            </div>

            <div class="algorithm-info">
                <h3>üî• Hybrid GA-SA Algorithm</h3>
                <p>Combines genetic evolution with simulated annealing for optimal routes</p>
            </div>

            <div class="instructions">
                <strong>How to use:</strong><br>
                1. Enter your Geoapify API key<br>
                2. Click on the map to add waypoints<br>
                3. Configure GA-SA parameters<br>
                4. Click "Solve with GA-SA" to find optimal route
            </div>

            <div class="input-group">
                <label for="apiKey">üîë Geoapify API Key</label>
                <input type="text" id="apiKey" placeholder="Enter your API key here..." value="198f00f10c64466e9168541cb8df922c">
            </div>

            <div class="input-group">
                <label for="transportMode">üöó Transportation Mode</label>
                <select id="transportMode">
                    <option value="drive">Driving</option>
                    <option value="walk">Walking</option>
                    <option value="bicycle">Bicycle</option>
                </select>
            </div>

            <div class="ga-parameters">
                <h4>üß¨ GA-SA Parameters</h4>
                <div class="param-grid">
                    <div class="input-group">
                        <label for="populationSize">üë• Population Size</label>
                        <input type="number" id="populationSize" value="50" min="20" max="100">
                    </div>
                    <div class="input-group">
                        <label for="generations">üîÑ Generations</label>
                        <input type="number" id="generations" value="80" min="30" max="200">
                    </div>
                </div>
                <div class="param-grid">
                    <div class="input-group">
                        <label for="mutationRate">üß™ Mutation Rate</label>
                        <input type="number" id="mutationRate" value="0.02" min="0.01" max="0.1" step="0.01">
                    </div>
                    <div class="input-group">
                        <label for="initialTemp">üå°Ô∏è SA Temperature</label>
                        <input type="number" id="initialTemp" value="1000" min="100" max="2000">
                    </div>
                </div>
            </div>

            <div class="input-group">
                <label>üìç Waypoints (<span id="pointCount">0</span>)</label>
                <div class="points-list" id="pointsList">
                    <p style="text-align: center; color: #a0aec0; font-style: italic;">Click on the map to add waypoints</p>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button class="btn btn-secondary" onclick="clearPoints()">üóëÔ∏è Clear All</button>
                <button class="btn btn-primary" onclick="solveGASA()">üöÄ Solve with GA-SA</button>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Running GA-SA Algorithm...</p>
                <p id="loadingStatus"></p>
                <div class="progress-bars" id="progressBars" style="display: none;">
                    <div class="progress-label">Generation Progress</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="generationProgress"></div>
                    </div>
                    <div class="progress-label">Temperature Cooling</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="temperatureProgress"></div>
                    </div>
                </div>
            </div>

            <div id="results"></div>
        </div>
    </div>

    <script>
        // Global variables
        let map;
        let waypoints = [];
        let waypointMarkers = [];
        let routeLayer = null;
        let distanceCache = {};

        // GA-SA Algorithm variables
        let currentGeneration = 0;
        let currentTemperature = 1000;
        let isRunning = false;

        // Initialize map
        function initMap() {
            const apiKey = document.getElementById('apiKey').value;
            if (!apiKey) {
                alert('Please enter your Geoapify API key first!');
                return;
            }

            map = new maplibregl.Map({
                container: 'map',
                style: `https://maps.geoapify.com/v1/styles/osm-bright/style.json?apiKey=${apiKey}`,
                center: [-98.5795, 39.8283], // Center of USA
                zoom: 4
            });

            map.addControl(new maplibregl.NavigationControl());

            // Add click event to map
            map.on('click', (e) => {
                if (!isRunning) {
                    addWaypoint(e.lngLat.lat, e.lngLat.lng);
                }
            });

            // Change cursor on hover
            map.on('mouseenter', () => {
                map.getCanvas().style.cursor = isRunning ? 'default' : 'crosshair';
            });
        }

        // Create numbered marker element
        function createNumberedMarker(number, isStart = false) {
            const markerElement = document.createElement('div');
            markerElement.className = `numbered-marker ${isStart ? 'start' : ''}`;
            markerElement.textContent = number;
            return markerElement;
        }

        // Add waypoint to map and list
        function addWaypoint(lat, lng) {
            const point = { lat: lat, lng: lng };
            waypoints.push(point);

            // Create numbered marker
            const markerNumber = waypoints.length;
            const isStart = markerNumber === 1;
            const markerElement = createNumberedMarker(markerNumber, isStart);

            // Add marker to map
            const marker = new maplibregl.Marker({ element: markerElement })
                .setLngLat([lng, lat])
                .setPopup(new maplibregl.Popup().setHTML(`
                    <strong>Waypoint ${markerNumber}${isStart ? ' (Start)' : ''}</strong><br>
                    Lat: ${lat.toFixed(6)}<br>
                    Lng: ${lng.toFixed(6)}
                `))
                .addTo(map);

            waypointMarkers.push(marker);

            updatePointsList();
            updatePointCount();
        }

        // Remove waypoint
        function removeWaypoint(index) {
            waypoints.splice(index, 1);
            waypointMarkers[index].remove();
            waypointMarkers.splice(index, 1);
            
            // Update all remaining markers with new numbers
            waypointMarkers.forEach((marker, i) => {
                const newNumber = i + 1;
                const isStart = newNumber === 1;
                const markerElement = createNumberedMarker(newNumber, isStart);
                marker.setElement(markerElement);
                
                // Update popup
                const point = waypoints[i];
                marker.setPopup(new maplibregl.Popup().setHTML(`
                    <strong>Waypoint ${newNumber}${isStart ? ' (Start)' : ''}</strong><br>
                    Lat: ${point.lat.toFixed(6)}<br>
                    Lng: ${point.lng.toFixed(6)}
                `));
            });
            
            updatePointsList();
            updatePointCount();
        }

        // Clear all waypoints
        function clearPoints() {
            if (isRunning) return;
            
            waypoints = [];
            waypointMarkers.forEach(marker => marker.remove());
            waypointMarkers = [];
            
            // Remove route if it exists
            if (routeLayer && map.getLayer('route')) {
                map.removeLayer('route');
                map.removeSource('route');
                routeLayer = null;
            }
            
            updatePointsList();
            updatePointCount();
            document.getElementById('results').innerHTML = '';
        }

        // Update points list in UI
        function updatePointsList() {
            const pointsList = document.getElementById('pointsList');
            
            if (waypoints.length === 0) {
                pointsList.innerHTML = '<p style="text-align: center; color: #a0aec0; font-style: italic;">Click on the map to add waypoints</p>';
                return;
            }

            pointsList.innerHTML = waypoints.map((point, index) => `
                <div class="point-item">
                    <div>
                        <strong>Point ${index + 1}${index === 0 ? ' (Start)' : ''}</strong><br>
                        <span class="point-coords">${point.lat.toFixed(4)}, ${point.lng.toFixed(4)}</span>
                    </div>
                    <button class="point-remove" onclick="removeWaypoint(${index})" ${isRunning ? 'disabled' : ''}>√ó</button>
                </div>
            `).join('');
        }

        // Update point count
        function updatePointCount() {
            document.getElementById('pointCount').textContent = waypoints.length;
        }

        // Get route distance using Geoapify API
        async function getRouteDistance(fromCoords, toCoords, mode = 'drive') {
            const cacheKey = `${fromCoords.lat},${fromCoords.lng}|${toCoords.lat},${toCoords.lng}|${mode}`;
            
            if (distanceCache[cacheKey]) {
                return distanceCache[cacheKey];
            }

            const apiKey = document.getElementById('apiKey').value;
            const waypoints = `${fromCoords.lat},${fromCoords.lng}|${toCoords.lat},${toCoords.lng}`;
            
            const url = `https://api.geoapify.com/v1/routing?waypoints=${waypoints}&mode=${mode}&format=json&apiKey=${apiKey}`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    const distance = data.results[0].distance;
                    distanceCache[cacheKey] = distance;
                    return distance;
                } else {
                    console.warn(`No ${mode} route found, using straight-line distance with penalty`);
                    const straightDistance = calculateHaversineDistance(fromCoords, toCoords);
                    const penalizedDistance = straightDistance * (mode === 'walk' ? 1.5 : mode === 'bicycle' ? 1.3 : 1.2);
                    distanceCache[cacheKey] = penalizedDistance;
                    return penalizedDistance;
                }
            } catch (error) {
                console.error('API request failed:', error);
                const straightDistance = calculateHaversineDistance(fromCoords, toCoords);
                const penalizedDistance = straightDistance * 1.5;
                distanceCache[cacheKey] = penalizedDistance;
                return penalizedDistance;
            }
        }

        // Calculate straight-line distance using Haversine formula
        function calculateHaversineDistance(coord1, coord2) {
            const R = 6371000; // Earth's radius in meters
            const lat1Rad = coord1.lat * Math.PI / 180;
            const lat2Rad = coord2.lat * Math.PI / 180;
            const deltaLat = (coord2.lat - coord1.lat) * Math.PI / 180;
            const deltaLng = (coord2.lng - coord1.lng) * Math.PI / 180;

            const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                    Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                    Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c; // Distance in meters
        }

        // Create distance matrix
        async function createDistanceMatrix(points, mode) {
            const n = points.length;
            const matrix = Array(n).fill().map(() => Array(n).fill(0));
            
            const totalRequests = n * (n - 1);
            let completedRequests = 0;
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (i !== j) {
                        const distance = await getRouteDistance(points[i], points[j], mode);
                        matrix[i][j] = distance;
                        completedRequests++;
                        
                        // Update progress
                        const progress = Math.round((completedRequests / totalRequests) * 100);
                        document.getElementById('loadingStatus').textContent = 
                            `Building distance matrix: ${progress}% (${completedRequests}/${totalRequests})`;
                        
                        // Small delay to respect rate limits
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
            }
            
            return matrix;
        }

        // Calculate fitness (total distance) for a path
        function calculateFitness(path, distanceMatrix) {
            let totalDistance = 0;
            for (let i = 0; i < path.length; i++) {
                const from = path[i];
                const to = path[(i + 1) % path.length];
                totalDistance += distanceMatrix[from][to];
            }
            return totalDistance;
        }

        // GA-SA: Initialize population
        function initializePopulation(size, numCities) {
            const population = [];
            for (let i = 0; i < size; i++) {
                const individual = Array.from({length: numCities}, (_, index) => index);
                // Shuffle the array
                for (let j = individual.length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [individual[j], individual[k]] = [individual[k], individual[j]];
                }
                population.push(individual);
            }
            return population;
        }

        // GA-SA: Selection (Tournament with SA)
        function tournamentSelection(population, fitnesses, temperature, tournamentSize = 3) {
            const selected = [];
            
            for (let i = 0; i < 2; i++) {
                const tournament = [];
                for (let j = 0; j < tournamentSize; j++) {
                    const index = Math.floor(Math.random() * population.length);
                    tournament.push({index, fitness: fitnesses[index]});
                }
                
                tournament.sort((a, b) => a.fitness - b.fitness);
                
                // SA-based selection from tournament
                let selectedIndex = tournament[0].index; // Best by default
                
                for (let k = 1; k < tournament.length; k++) {
                    const fitnessDiff = tournament[k].fitness - tournament[0].fitness;
                    if (temperature > 0) {
                        const probability = Math.exp(-fitnessDiff / (temperature * 1000));
                        if (Math.random() < probability) {
                            selectedIndex = tournament[k].index;
                            break;
                        }
                    }
                }
                
                selected.push(population[selectedIndex].slice());
            }
            
            return selected;
        }

        // GA-SA: Order Crossover (OX)
        function orderCrossover(parent1, parent2) {
            const length = parent1.length;
            const start = Math.floor(Math.random() * length);
            const end = Math.floor(Math.random() * (length - start)) + start;
            
            const child1 = Array(length).fill(-1);
            const child2 = Array(length).fill(-1);
            
            // Copy segments
            for (let i = start; i <= end; i++) {
                child1[i] = parent1[i];
                child2[i] = parent2[i];
            }
            
            // Fill remaining positions
            let pos1 = 0, pos2 = 0;
            
            for (let i = 0; i < length; i++) {
                if (!child1.includes(parent2[i])) {
                    while (child1[pos1] !== -1) pos1++;
                    child1[pos1] = parent2[i];
                }
                
                if (!child2.includes(parent1[i])) {
                    while (child2[pos2] !== -1) pos2++;
                    child2[pos2] = parent1[i];
                }
            }
            
            return [child1, child2];
        }

        // GA-SA: Mutation with SA acceptance
        function saAdaptiveMutation(individual, distanceMatrix, temperature, mutationRate) {
            if (Math.random() > mutationRate) return individual;
            
            const currentFitness = calculateFitness(individual, distanceMatrix);
            let bestMutant = individual.slice();
            let bestFitness = currentFitness;
            
            // Try different mutation types
            const mutationTypes = ['swap', '2opt', 'insert'];
            
            for (const mutationType of mutationTypes) {
                const mutant = individual.slice();
                
                if (mutationType === 'swap') {
                    const i = Math.floor(Math.random() * mutant.length);
                    const j = Math.floor(Math.random() * mutant.length);
                    [mutant[i], mutant[j]] = [mutant[j], mutant[i]];
                } else if (mutationType === '2opt') {
                    const i = Math.floor(Math.random() * mutant.length);
                    const k = Math.floor(Math.random() * mutant.length);
                    if (i !== k) {
                        const start = Math.min(i, k);
                        const end = Math.max(i, k);
                        const segment = mutant.slice(start, end + 1).reverse();
                        mutant.splice(start, end - start + 1, ...segment);
                    }
                } else if (mutationType === 'insert') {
                    const i = Math.floor(Math.random() * mutant.length);
                    const j = Math.floor(Math.random() * mutant.length);
                    const city = mutant.splice(i, 1)[0];
                    mutant.splice(j, 0, city);
                }
                
                const mutantFitness = calculateFitness(mutant, distanceMatrix);
                
                // SA acceptance
                if (mutantFitness < bestFitness) {
                    bestMutant = mutant;
                    bestFitness = mutantFitness;
                } else if (temperature > 0) {
                    const delta = mutantFitness - bestFitness;
                    const probability = Math.exp(-delta / (temperature * 50));
                    if (Math.random() < probability) {
                        bestMutant = mutant;
                        bestFitness = mutantFitness;
                    }
                }
            }
            
            return bestMutant;
        }

        // GA-SA: Local search with SA
        function saLocalSearch(individual, distanceMatrix, temperature, maxIterations = 20) {
            let current = individual.slice();
            let currentFitness = calculateFitness(current, distanceMatrix);
            
            for (let iter = 0; iter < maxIterations; iter++) {
                const neighbor = current.slice();
                
                // Random neighborhood operation
                if (Math.random() < 0.5) {
                    // 2-opt
                    const i = Math.floor(Math.random() * neighbor.length);
                    const k = Math.floor(Math.random() * neighbor.length);
                    if (i !== k) {
                        const start = Math.min(i, k);
                        const end = Math.max(i, k);
                        const segment = neighbor.slice(start, end + 1).reverse();
                        neighbor.splice(start, end - start + 1, ...segment);
                    }
                } else {
                    // Swap
                    const i = Math.floor(Math.random() * neighbor.length);
                    const j = Math.floor(Math.random() * neighbor.length);
                    [neighbor[i], neighbor[j]] = [neighbor[j], neighbor[i]];
                }
                
                const neighborFitness = calculateFitness(neighbor, distanceMatrix);
                
                // SA acceptance
                if (neighborFitness < currentFitness) {
                    current = neighbor;
                    currentFitness = neighborFitness;
                } else if (temperature > 0) {
                    const delta = neighborFitness - currentFitness;
                    const probability = Math.exp(-delta / (temperature * 100));
                    if (Math.random() < probability) {
                        current = neighbor;
                        currentFitness = neighborFitness;
                    }
                }
            }
            
            return current;
        }

        // Main GA-SA algorithm
        async function runGASA(points, distanceMatrix, params) {
            const { populationSize, generations, mutationRate, initialTemp } = params;
            
            // Initialize
            let population = initializePopulation(populationSize, points.length);
            currentTemperature = initialTemp;
            const coolingRate = 0.95;
            
            let bestSolution = null;
            let bestFitness = Infinity;
            let fitnessHistory = [];
            
            // Show progress bars
            document.getElementById('progressBars').style.display = 'block';
            
            for (let generation = 0; generation < generations; generation++) {
                currentGeneration = generation;
                
                // Calculate fitness for all individuals
                const fitnesses = population.map(individual => 
                    calculateFitness(individual, distanceMatrix)
                );
                
                // Track best solution
                const genBestIndex = fitnesses.indexOf(Math.min(...fitnesses));
                const genBestFitness = fitnesses[genBestIndex];
                
                if (genBestFitness < bestFitness) {
                    bestFitness = genBestFitness;
                    bestSolution = population[genBestIndex].slice();
                }
                
                fitnessHistory.push(bestFitness);
                
                // Update progress
                const genProgress = ((generation + 1) / generations) * 100;
                const tempProgress = ((initialTemp - currentTemperature) / initialTemp) * 100;
                
                document.getElementById('generationProgress').style.width = `${genProgress}%`;
                document.getElementById('temperatureProgress').style.width = `${tempProgress}%`;
                document.getElementById('loadingStatus').innerHTML = 
                    `Generation: ${generation + 1}/${generations}<br>
                     Temperature: ${currentTemperature.toFixed(1)}<br>
                     Best Distance: ${(bestFitness / 1000).toFixed(2)} km`;
                
                // Create new population
                const newPopulation = [];
                
                // Elite selection (keep best 10%)
                const eliteCount = Math.floor(populationSize * 0.1);
                const sortedIndices = fitnesses
                    .map((fitness, index) => ({ fitness, index }))
                    .sort((a, b) => a.fitness - b.fitness)
                    .slice(0, eliteCount);
                
                sortedIndices.forEach(({ index }) => {
                    newPopulation.push(population[index].slice());
                });
                
                // Generate offspring
                while (newPopulation.length < populationSize) {
                    const [parent1, parent2] = tournamentSelection(population, fitnesses, currentTemperature);
                    const [child1, child2] = orderCrossover(parent1, parent2);
                    
                    // Apply SA-adaptive mutation
                    const mutatedChild1 = saAdaptiveMutation(child1, distanceMatrix, currentTemperature, mutationRate);
                    const mutatedChild2 = saAdaptiveMutation(child2, distanceMatrix, currentTemperature, mutationRate);
                    
                    // Apply local search with probability
                    const localSearchProb = 0.1;
                    const finalChild1 = Math.random() < localSearchProb ? 
                        saLocalSearch(mutatedChild1, distanceMatrix, currentTemperature) : mutatedChild1;
                    const finalChild2 = Math.random() < localSearchProb ? 
                        saLocalSearch(mutatedChild2, distanceMatrix, currentTemperature) : mutatedChild2;
                    
                    newPopulation.push(finalChild1);
                    if (newPopulation.length < populationSize) {
                        newPopulation.push(finalChild2);
                    }
                }
                
                population = newPopulation;
                
                // Cool down temperature
                currentTemperature *= coolingRate;
                
                // Small delay for UI updates
                await new Promise(resolve => setTimeout(resolve, 50));
            }
            
            return { bestSolution, bestFitness, fitnessHistory };
        }

        // Draw route on map
        async function drawRoute(solution, mode) {
            const apiKey = document.getElementById('apiKey').value;
            const routeWaypoints = solution.map(index => waypoints[index]);
            
            // Add return to start
            routeWaypoints.push(waypoints[solution[0]]);
            
            const waypointsString = routeWaypoints
                .map(point => `${point.lat},${point.lng}`)
                .join('|');
            
            const url = `https://api.geoapify.com/v1/routing?waypoints=${waypointsString}&mode=${mode}&format=geojson&apiKey=${apiKey}`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.features && data.features.length > 0) {
                    // Remove existing route
                    if (map.getLayer('route')) {
                        map.removeLayer('route');
                        map.removeSource('route');
                    }
                    
                    // Add new route
                    map.addSource('route', {
                        type: 'geojson',
                        data: data
                    });
                    
                    map.addLayer({
                        id: 'route',
                        type: 'line',
                        source: 'route',
                        layout: {
                            'line-join': 'round',
                            'line-cap': 'round'
                        },
                        paint: {
                            'line-color': '#667eea',
                            'line-width': 4,
                            'line-opacity': 0.8
                        }
                    });
                    
                    routeLayer = 'route';
                    
                    // Fit map to route bounds
                    const bounds = new maplibregl.LngLatBounds();
                    routeWaypoints.forEach(point => {
                        bounds.extend([point.lng, point.lat]);
                    });
                    map.fitBounds(bounds, { padding: 50 });
                }
            } catch (error) {
                console.error('Error drawing route:', error);
            }
        }

        // Format distance for display
        function formatDistance(meters) {
            if (meters >= 1000) {
                return `${(meters / 1000).toFixed(2)} km`;
            } else {
                return `${Math.round(meters)} m`;
            }
        }

        // Format time for display
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else {
                return `${minutes}m`;
            }
        }

        // Main solve function
        async function solveGASA() {
            if (waypoints.length < 3) {
                alert('Please add at least 3 waypoints to solve the TSP!');
                return;
            }
            
            if (!document.getElementById('apiKey').value.trim()) {
                alert('Please enter your Geoapify API key!');
                return;
            }
            
            isRunning = true;
            document.getElementById('loading').classList.add('show');
            document.getElementById('results').innerHTML = '';
            
            try {
                // Get parameters
                const params = {
                    populationSize: parseInt(document.getElementById('populationSize').value),
                    generations: parseInt(document.getElementById('generations').value),
                    mutationRate: parseFloat(document.getElementById('mutationRate').value),
                    initialTemp: parseFloat(document.getElementById('initialTemp').value)
                };
                
                const mode = document.getElementById('transportMode').value;
                
                // Create distance matrix
                document.getElementById('loadingStatus').textContent = 'Building distance matrix...';
                const distanceMatrix = await createDistanceMatrix(waypoints, mode);
                
                // Run GA-SA algorithm
                document.getElementById('loadingStatus').textContent = 'Running GA-SA algorithm...';
                const result = await runGASA(waypoints, distanceMatrix, params);
                
                // Draw optimal route
                document.getElementById('loadingStatus').textContent = 'Drawing optimal route...';
                await drawRoute(result.bestSolution, mode);
                
                // Display results
                const totalDistance = result.bestFitness;
                const estimatedTime = totalDistance / (mode === 'walk' ? 1.4 : mode === 'bicycle' ? 5.5 : 13.9); // rough estimates
                
                const routeOrder = result.bestSolution.map(index => index + 1).join(' ‚Üí ') + ' ‚Üí 1';
                
                document.getElementById('results').innerHTML = `
                    <div class="results">
                        <h3>üéØ GA-SA Optimization Results</h3>
                        <p><strong>üõ£Ô∏è Total Distance:</strong> ${formatDistance(totalDistance)}</p>
                        <p><strong>‚è±Ô∏è Estimated Time:</strong> ${formatTime(estimatedTime)}</p>
                        <p><strong>üîÑ Route Order:</strong> ${routeOrder}</p>
                        <p><strong>üß¨ Algorithm:</strong> Genetic Algorithm with Simulated Annealing</p>
                        <p><strong>üìä Generations:</strong> ${params.generations}</p>
                        <p><strong>üë• Population Size:</strong> ${params.populationSize}</p>
                        <p><strong>üå°Ô∏è Final Temperature:</strong> ${currentTemperature.toFixed(2)}</p>
                    </div>
                `;
                
            } catch (error) {
                console.error('Error solving TSP:', error);
                alert('Error occurred while solving TSP. Please check your API key and try again.');
            } finally {
                isRunning = false;
                document.getElementById('loading').classList.remove('show');
                document.getElementById('progressBars').style.display = 'none';
                map.getCanvas().style.cursor = 'crosshair';
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            
            // API key change handler
            document.getElementById('apiKey').addEventListener('change', function() {
                if (this.value.trim()) {
                    // Reinitialize map with new API key
                    if (map) {
                        map.remove();
                    }
                    initMap();
                }
            });
        });
    </script>
</body>
</html>